{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///react-maskedinput.min.js","webpack:///webpack/bootstrap 4682262fdc5538e1e53d","webpack:///./src/index.js","webpack:///./~/fbjs/lib/ExecutionEnvironment.js","webpack:///./~/fbjs/lib/containsNode.js","webpack:///./~/fbjs/lib/focusNode.js","webpack:///./~/fbjs/lib/getActiveElement.js","webpack:///./~/fbjs/lib/isNode.js","webpack:///./~/fbjs/lib/isTextNode.js","webpack:///./~/inputmask-core/lib/index.js","webpack:///./~/react/lib/ReactDOMSelection.js","webpack:///./~/react/lib/ReactInputSelection.js","webpack:///./~/react/lib/getNodeForCharacterOffset.js","webpack:///./~/react/lib/getTextContentAccessor.js","webpack:///external {\"root\":\"React\",\"commonjs2\":\"react\",\"commonjs\":\"react\",\"amd\":\"react\"}"],"names":["root","factory","exports","module","require","define","amd","this","__WEBPACK_EXTERNAL_MODULE_12__","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","_objectWithoutProperties","obj","keys","target","i","indexOf","Object","prototype","hasOwnProperty","isUndo","e","ctrlKey","metaKey","keyCode","shiftKey","KEYCODE_Y","KEYCODE_Z","isRedo","_extends","assign","arguments","length","source","key","React","_require","getSelection","setSelection","InputMask","MaskedInput","createClass","displayName","propTypes","mask","PropTypes","string","isRequired","formatCharacters","object","placeholderChar","getDefaultProps","value","componentWillMount","options","pattern","props","componentWillReceiveProps","nextProps","setPattern","getRawValue","setValue","componentWillUpdate","nextState","_updatePattern","componentDidUpdate","prevProps","selection","start","_updateInputSelection","input","_updateMaskSelection","_onChange","maskValue","getValue","sizeDiff","end","backspace","_getDisplayValue","onChange","_onKeyDown","preventDefault","undo","redo","_onKeyPress","altKey","_onPaste","paste","clipboardData","getData","setTimeout","emptyValue","focus","blur","render","_this","_props","size","placeholder","patternLength","createElement","ref","r","maxLength","onKeyDown","onKeyPress","onPaste","canUseDOM","window","document","ExecutionEnvironment","canUseWorkers","Worker","canUseEventListeners","addEventListener","attachEvent","canUseViewport","screen","isInWorker","containsNode","outerNode","innerNode","isTextNode","parentNode","contains","compareDocumentPosition","focusNode","node","getActiveElement","activeElement","body","isNode","Node","nodeType","nodeName","extend","dest","src","l","copy","mergeFormatCharacters","merged","DEFAULT_FORMAT_CHARACTERS","chars","char","Pattern","DEFAULT_PLACEHOLDER_CHAR","firstEditableIndex","lastEditableIndex","_editableIndices","_parse","Error","ESCAPE_CHAR","DIGIT_RE","LETTER_RE","ALPHANNUMERIC_RE","*","validate","test","1","a","A","transform","toUpperCase","#","sourceChars","split","patternIndex","push","formatValue","valueBuffer","Array","valueIndex","isEditableIndex","isValidAtIndex","index","format","selectionBefore","valueBefore","inputIndex","_historyIndex","console","log","_history","splice","_lastOp","_lastSelection","lastOp","initialState","slice","charAt","substring","valid","historyItem","startUndo","pop","join","_resetHistory","rawValue","isCollapsed","anchorNode","anchorOffset","focusOffset","getIEOffsets","selectedRange","createRange","selectedLength","text","fromStart","duplicate","moveToElementText","setEndPoint","startOffset","endOffset","getModernOffsets","rangeCount","currentRange","getRangeAt","startContainer","endContainer","isSelectionCollapsed","rangeLength","toString","tempRange","cloneRange","selectNodeContents","setEnd","isTempRangeCollapsed","detectionRange","setStart","isBackward","collapsed","setIEOffsets","offsets","range","undefined","moveStart","moveEnd","select","setModernOffsets","getTextContentAccessor","Math","min","temp","startMarker","getNodeForCharacterOffset","endMarker","offset","removeAllRanges","addRange","useIEOffsets","ReactDOMSelection","getOffsets","setOffsets","isInDocument","documentElement","ReactInputSelection","hasSelectionCapabilities","elem","toLowerCase","type","contentEditable","getSelectionInformation","focusedElem","selectionRange","restoreSelection","priorSelectionInformation","curFocusedElem","priorFocusedElem","priorSelectionRange","selectionStart","selectionEnd","parentElement","createTextRange","collapse","getLeafNode","firstChild","getSiblingNode","nextSibling","nodeStart","nodeEnd","textContent","contentKey"],"mappings":"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","file":"react-maskedinput.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"react\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"react\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"MaskedInput\"] = factory(require(\"react\"));\n\telse\n\t\troot[\"MaskedInput\"] = factory(root[\"React\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_12__) {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"react\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"react\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"MaskedInput\"] = factory(require(\"react\"));\n\telse\n\t\troot[\"MaskedInput\"] = factory(root[\"React\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_12__) {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\t\n\tfunction _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }\n\t\n\tvar React = __webpack_require__(12);\n\t\n\tvar _require = __webpack_require__(9);\n\t\n\tvar getSelection = _require.getSelection;\n\tvar setSelection = _require.setSelection;\n\t\n\tvar InputMask = __webpack_require__(7);\n\t\n\tvar KEYCODE_Z = 90;\n\tvar KEYCODE_Y = 89;\n\t\n\tfunction isUndo(e) {\n\t  return (e.ctrlKey || e.metaKey) && e.keyCode === (e.shiftKey ? KEYCODE_Y : KEYCODE_Z);\n\t}\n\t\n\tfunction isRedo(e) {\n\t  return (e.ctrlKey || e.metaKey) && e.keyCode === (e.shiftKey ? KEYCODE_Z : KEYCODE_Y);\n\t}\n\t\n\tvar MaskedInput = React.createClass({\n\t  displayName: 'MaskedInput',\n\t\n\t  propTypes: {\n\t    mask: React.PropTypes.string.isRequired,\n\t\n\t    formatCharacters: React.PropTypes.object,\n\t    placeholderChar: React.PropTypes.string\n\t  },\n\t\n\t  getDefaultProps: function getDefaultProps() {\n\t    return {\n\t      value: ''\n\t    };\n\t  },\n\t\n\t  componentWillMount: function componentWillMount() {\n\t    var options = {\n\t      pattern: this.props.mask,\n\t      value: this.props.value,\n\t      formatCharacters: this.props.formatCharacters\n\t    };\n\t    if (this.props.placeholderChar) {\n\t      options.placeholderChar = this.props.placeholderChar;\n\t    }\n\t    this.mask = new InputMask(options);\n\t  },\n\t\n\t  componentWillReceiveProps: function componentWillReceiveProps(nextProps) {\n\t    // update the pattern first to avoid left over placeholders\n\t    if (this.props.mask !== nextProps.mask) {\n\t      this.mask.setPattern(nextProps.mask, { value: this.mask.getRawValue() });\n\t    }\n\t    if (this.props.value !== nextProps.value) {\n\t      this.mask.setValue(nextProps.value);\n\t    }\n\t  },\n\t\n\t  componentWillUpdate: function componentWillUpdate(nextProps, nextState) {\n\t    if (nextProps.mask !== this.props.mask) {\n\t      this._updatePattern(nextProps);\n\t    }\n\t  },\n\t\n\t  componentDidUpdate: function componentDidUpdate(prevProps) {\n\t    if (prevProps.mask !== this.props.mask && this.mask.selection.start) {\n\t      this._updateInputSelection();\n\t    }\n\t  },\n\t\n\t  _updatePattern: function _updatePattern(props) {\n\t    this.mask.setPattern(props.mask, {\n\t      value: this.mask.getRawValue(),\n\t      selection: getSelection(this.input)\n\t    });\n\t  },\n\t\n\t  _updateMaskSelection: function _updateMaskSelection() {\n\t    this.mask.selection = getSelection(this.input);\n\t  },\n\t\n\t  _updateInputSelection: function _updateInputSelection() {\n\t    setSelection(this.input, this.mask.selection);\n\t  },\n\t\n\t  _onChange: function _onChange(e) {\n\t    // console.log('onChange', JSON.stringify(getSelection(this.input)), e.target.value)\n\t\n\t    var maskValue = this.mask.getValue();\n\t    if (e.target.value !== maskValue) {\n\t      // Cut or delete operations will have shortened the value\n\t      if (e.target.value.length < maskValue.length) {\n\t        var sizeDiff = maskValue.length - e.target.value.length;\n\t        this._updateMaskSelection();\n\t        this.mask.selection.end = this.mask.selection.start + sizeDiff;\n\t        this.mask.backspace();\n\t      } else {\n\t        this.mask.setValue(e.target.value);\n\t      }\n\t      var value = this._getDisplayValue();\n\t      e.target.value = value;\n\t      if (value) {\n\t        this._updateInputSelection();\n\t      }\n\t    }\n\t    if (this.props.onChange) {\n\t      this.props.onChange(e);\n\t    }\n\t  },\n\t\n\t  _onKeyDown: function _onKeyDown(e) {\n\t    // console.log('onKeyDown', JSON.stringify(getSelection(this.input)), e.key, e.target.value)\n\t\n\t    if (isUndo(e)) {\n\t      e.preventDefault();\n\t      if (this.mask.undo()) {\n\t        e.target.value = this._getDisplayValue();\n\t        this._updateInputSelection();\n\t        if (this.props.onChange) {\n\t          this.props.onChange(e);\n\t        }\n\t      }\n\t      return;\n\t    } else if (isRedo(e)) {\n\t      e.preventDefault();\n\t      if (this.mask.redo()) {\n\t        e.target.value = this._getDisplayValue();\n\t        this._updateInputSelection();\n\t        if (this.props.onChange) {\n\t          this.props.onChange(e);\n\t        }\n\t      }\n\t      return;\n\t    }\n\t\n\t    if (e.key === 'Backspace') {\n\t      e.preventDefault();\n\t      this._updateMaskSelection();\n\t      if (this.mask.backspace()) {\n\t        var value = this._getDisplayValue();\n\t        e.target.value = value;\n\t        if (value) {\n\t          this._updateInputSelection();\n\t        }\n\t        if (this.props.onChange) {\n\t          this.props.onChange(e);\n\t        }\n\t      }\n\t    }\n\t  },\n\t\n\t  _onKeyPress: function _onKeyPress(e) {\n\t    // console.log('onKeyPress', JSON.stringify(getSelection(this.input)), e.key, e.target.value)\n\t\n\t    // Ignore modified key presses\n\t    // Ignore enter key to allow form submission\n\t    if (e.metaKey || e.altKey || e.ctrlKey || e.key === 'Enter') {\n\t      return;\n\t    }\n\t\n\t    e.preventDefault();\n\t    this._updateMaskSelection();\n\t    if (this.mask.input(e.key)) {\n\t      e.target.value = this.mask.getValue();\n\t      this._updateInputSelection();\n\t      if (this.props.onChange) {\n\t        this.props.onChange(e);\n\t      }\n\t    }\n\t  },\n\t\n\t  _onPaste: function _onPaste(e) {\n\t    // console.log('onPaste', JSON.stringify(getSelection(this.input)), e.clipboardData.getData('Text'), e.target.value)\n\t\n\t    e.preventDefault();\n\t    this._updateMaskSelection();\n\t    // getData value needed for IE also works in FF & Chrome\n\t    if (this.mask.paste(e.clipboardData.getData('Text'))) {\n\t      e.target.value = this.mask.getValue();\n\t      // Timeout needed for IE\n\t      setTimeout(this._updateInputSelection, 0);\n\t      if (this.props.onChange) {\n\t        this.props.onChange(e);\n\t      }\n\t    }\n\t  },\n\t\n\t  _getDisplayValue: function _getDisplayValue() {\n\t    var value = this.mask.getValue();\n\t    return value === this.mask.emptyValue ? '' : value;\n\t  },\n\t\n\t  focus: function focus() {\n\t    this.input.focus();\n\t  },\n\t\n\t  blur: function blur() {\n\t    this.input.blur();\n\t  },\n\t\n\t  render: function render() {\n\t    var _this = this;\n\t\n\t    var _props = this.props;\n\t    var mask = _props.mask;\n\t    var formatCharacters = _props.formatCharacters;\n\t    var size = _props.size;\n\t    var placeholder = _props.placeholder;\n\t    var placeholderChar = _props.placeholderChar;\n\t\n\t    var props = _objectWithoutProperties(_props, ['mask', 'formatCharacters', 'size', 'placeholder', 'placeholderChar']);\n\t\n\t    var patternLength = this.mask.pattern.length;\n\t    return React.createElement('input', _extends({}, props, {\n\t      ref: function (r) {\n\t        return _this.input = r;\n\t      },\n\t      maxLength: patternLength,\n\t      onChange: this._onChange,\n\t      onKeyDown: this._onKeyDown,\n\t      onKeyPress: this._onKeyPress,\n\t      onPaste: this._onPaste,\n\t      placeholder: placeholder || this.mask.emptyValue,\n\t      size: size || patternLength,\n\t      value: this._getDisplayValue()\n\t    }));\n\t  }\n\t});\n\t\n\tmodule.exports = MaskedInput;\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n\t/**\n\t * Copyright (c) 2013-present, Facebook, Inc.\n\t * All rights reserved.\n\t *\n\t * This source code is licensed under the BSD-style license found in the\n\t * LICENSE file in the root directory of this source tree. An additional grant\n\t * of patent rights can be found in the PATENTS file in the same directory.\n\t *\n\t */\n\t\n\t'use strict';\n\t\n\tvar canUseDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);\n\t\n\t/**\n\t * Simple, lightweight module assisting with the detection and context of\n\t * Worker. Helps avoid circular dependencies and allows code to reason about\n\t * whether or not they are in a Worker, even if they never include the main\n\t * `ReactWorker` dependency.\n\t */\n\tvar ExecutionEnvironment = {\n\t\n\t  canUseDOM: canUseDOM,\n\t\n\t  canUseWorkers: typeof Worker !== 'undefined',\n\t\n\t  canUseEventListeners: canUseDOM && !!(window.addEventListener || window.attachEvent),\n\t\n\t  canUseViewport: canUseDOM && !!window.screen,\n\t\n\t  isInWorker: !canUseDOM // For now, this is true - might change in the future.\n\t\n\t};\n\t\n\tmodule.exports = ExecutionEnvironment;\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t/**\n\t * Copyright (c) 2013-present, Facebook, Inc.\n\t * All rights reserved.\n\t *\n\t * This source code is licensed under the BSD-style license found in the\n\t * LICENSE file in the root directory of this source tree. An additional grant\n\t * of patent rights can be found in the PATENTS file in the same directory.\n\t *\n\t * \n\t */\n\t\n\tvar isTextNode = __webpack_require__(6);\n\t\n\t/*eslint-disable no-bitwise */\n\t\n\t/**\n\t * Checks if a given DOM node contains or is another DOM node.\n\t */\n\tfunction containsNode(outerNode, innerNode) {\n\t  if (!outerNode || !innerNode) {\n\t    return false;\n\t  } else if (outerNode === innerNode) {\n\t    return true;\n\t  } else if (isTextNode(outerNode)) {\n\t    return false;\n\t  } else if (isTextNode(innerNode)) {\n\t    return containsNode(outerNode, innerNode.parentNode);\n\t  } else if ('contains' in outerNode) {\n\t    return outerNode.contains(innerNode);\n\t  } else if (outerNode.compareDocumentPosition) {\n\t    return !!(outerNode.compareDocumentPosition(innerNode) & 16);\n\t  } else {\n\t    return false;\n\t  }\n\t}\n\t\n\tmodule.exports = containsNode;\n\n/***/ },\n/* 3 */\n/***/ function(module, exports) {\n\n\t/**\n\t * Copyright (c) 2013-present, Facebook, Inc.\n\t * All rights reserved.\n\t *\n\t * This source code is licensed under the BSD-style license found in the\n\t * LICENSE file in the root directory of this source tree. An additional grant\n\t * of patent rights can be found in the PATENTS file in the same directory.\n\t *\n\t */\n\t\n\t'use strict';\n\t\n\t/**\n\t * @param {DOMElement} node input/textarea to focus\n\t */\n\t\n\tfunction focusNode(node) {\n\t  // IE8 can throw \"Can't move focus to the control because it is invisible,\n\t  // not enabled, or of a type that does not accept the focus.\" for all kinds of\n\t  // reasons that are too expensive and fragile to test.\n\t  try {\n\t    node.focus();\n\t  } catch (e) {}\n\t}\n\t\n\tmodule.exports = focusNode;\n\n/***/ },\n/* 4 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\t/**\n\t * Copyright (c) 2013-present, Facebook, Inc.\n\t * All rights reserved.\n\t *\n\t * This source code is licensed under the BSD-style license found in the\n\t * LICENSE file in the root directory of this source tree. An additional grant\n\t * of patent rights can be found in the PATENTS file in the same directory.\n\t *\n\t * @typechecks\n\t */\n\t\n\t/* eslint-disable fb-www/typeof-undefined */\n\t\n\t/**\n\t * Same as document.activeElement but wraps in a try-catch block. In IE it is\n\t * not safe to call document.activeElement if there is nothing focused.\n\t *\n\t * The activeElement will be null only if the document or document body is not\n\t * yet defined.\n\t */\n\tfunction getActiveElement() /*?DOMElement*/{\n\t  if (typeof document === 'undefined') {\n\t    return null;\n\t  }\n\t  try {\n\t    return document.activeElement || document.body;\n\t  } catch (e) {\n\t    return document.body;\n\t  }\n\t}\n\t\n\tmodule.exports = getActiveElement;\n\n/***/ },\n/* 5 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\t/**\n\t * Copyright (c) 2013-present, Facebook, Inc.\n\t * All rights reserved.\n\t *\n\t * This source code is licensed under the BSD-style license found in the\n\t * LICENSE file in the root directory of this source tree. An additional grant\n\t * of patent rights can be found in the PATENTS file in the same directory.\n\t *\n\t * @typechecks\n\t */\n\t\n\t/**\n\t * @param {*} object The object to check.\n\t * @return {boolean} Whether or not the object is a DOM node.\n\t */\n\tfunction isNode(object) {\n\t  return !!(object && (typeof Node === 'function' ? object instanceof Node : typeof object === 'object' && typeof object.nodeType === 'number' && typeof object.nodeName === 'string'));\n\t}\n\t\n\tmodule.exports = isNode;\n\n/***/ },\n/* 6 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t/**\n\t * Copyright (c) 2013-present, Facebook, Inc.\n\t * All rights reserved.\n\t *\n\t * This source code is licensed under the BSD-style license found in the\n\t * LICENSE file in the root directory of this source tree. An additional grant\n\t * of patent rights can be found in the PATENTS file in the same directory.\n\t *\n\t * @typechecks\n\t */\n\t\n\tvar isNode = __webpack_require__(5);\n\t\n\t/**\n\t * @param {*} object The object to check.\n\t * @return {boolean} Whether or not the object is a DOM text node.\n\t */\n\tfunction isTextNode(object) {\n\t  return isNode(object) && object.nodeType == 3;\n\t}\n\t\n\tmodule.exports = isTextNode;\n\n/***/ },\n/* 7 */\n/***/ function(module, exports) {\n\n\t'use strict'\n\t\n\tfunction extend(dest, src) {\n\t  if (src) {\n\t    var props = Object.keys(src)\n\t    for (var i = 0, l = props.length; i < l ; i++) {\n\t      dest[props[i]] = src[props[i]]\n\t    }\n\t  }\n\t  return dest\n\t}\n\t\n\tfunction copy(obj) {\n\t  return extend({}, obj)\n\t}\n\t\n\t/**\n\t * Merge an object defining format characters into the defaults.\n\t * Passing null/undefined for en existing format character removes it.\n\t * Passing a definition for an existing format character overrides it.\n\t * @param {?Object} formatCharacters.\n\t */\n\tfunction mergeFormatCharacters(formatCharacters) {\n\t  var merged = copy(DEFAULT_FORMAT_CHARACTERS)\n\t  if (formatCharacters) {\n\t    var chars = Object.keys(formatCharacters)\n\t    for (var i = 0, l = chars.length; i < l ; i++) {\n\t      var char = chars[i]\n\t      if (formatCharacters[char] == null) {\n\t        delete merged[char]\n\t      }\n\t      else {\n\t        merged[char] = formatCharacters[char]\n\t      }\n\t    }\n\t  }\n\t  return merged\n\t}\n\t\n\tvar ESCAPE_CHAR = '\\\\'\n\t\n\tvar DIGIT_RE = /^\\d$/\n\tvar LETTER_RE = /^[A-Za-z]$/\n\tvar ALPHANNUMERIC_RE = /^[\\dA-Za-z]$/\n\t\n\tvar DEFAULT_PLACEHOLDER_CHAR = '_'\n\tvar DEFAULT_FORMAT_CHARACTERS = {\n\t  '*': {\n\t    validate: function(char) { return ALPHANNUMERIC_RE.test(char) }\n\t  },\n\t  '1': {\n\t    validate: function(char) { return DIGIT_RE.test(char) }\n\t  },\n\t  'a': {\n\t    validate: function(char) { return LETTER_RE.test(char) }\n\t  },\n\t  'A': {\n\t    validate: function(char) { return LETTER_RE.test(char) },\n\t    transform: function(char) { return char.toUpperCase() }\n\t  },\n\t  '#': {\n\t    validate: function(char) { return ALPHANNUMERIC_RE.test(char) },\n\t    transform: function(char) { return char.toUpperCase() }\n\t  }\n\t}\n\t\n\t/**\n\t * @param {string} source\n\t * @patam {?Object} formatCharacters\n\t */\n\tfunction Pattern(source, formatCharacters, placeholderChar) {\n\t  if (!(this instanceof Pattern)) {\n\t    return new Pattern(source, formatCharacters, placeholderChar)\n\t  }\n\t\n\t  /** Placeholder character */\n\t  this.placeholderChar = placeholderChar || DEFAULT_PLACEHOLDER_CHAR\n\t  /** Format character definitions. */\n\t  this.formatCharacters = formatCharacters || DEFAULT_FORMAT_CHARACTERS\n\t  /** Pattern definition string with escape characters. */\n\t  this.source = source\n\t  /** Pattern characters after escape characters have been processed. */\n\t  this.pattern = []\n\t  /** Length of the pattern after escape characters have been processed. */\n\t  this.length = 0\n\t  /** Index of the first editable character. */\n\t  this.firstEditableIndex = null\n\t  /** Index of the last editable character. */\n\t  this.lastEditableIndex = null\n\t\n\t  /** Lookup for indices of editable characters in the pattern. */\n\t  this._editableIndices = {}\n\t\n\t  this._parse()\n\t}\n\t\n\tPattern.prototype._parse = function parse() {\n\t  var sourceChars = this.source.split('')\n\t  var patternIndex = 0\n\t  var pattern = []\n\t\n\t  for (var i = 0, l = sourceChars.length; i < l; i++) {\n\t    var char = sourceChars[i]\n\t    if (char === ESCAPE_CHAR) {\n\t      if (i === l - 1) {\n\t        throw new Error('InputMask: pattern ends with a raw ' + ESCAPE_CHAR)\n\t      }\n\t      char = sourceChars[++i]\n\t    }\n\t    else if (char in this.formatCharacters) {\n\t      if (this.firstEditableIndex === null) {\n\t        this.firstEditableIndex = patternIndex\n\t      }\n\t      this.lastEditableIndex = patternIndex\n\t      this._editableIndices[patternIndex] = true\n\t    }\n\t\n\t    pattern.push(char)\n\t    patternIndex++\n\t  }\n\t\n\t  if (this.firstEditableIndex === null) {\n\t    throw new Error(\n\t      'InputMask: pattern \"' + this.source + '\" does not contain any editable characters.'\n\t    )\n\t  }\n\t\n\t  this.pattern = pattern\n\t  this.length = pattern.length\n\t}\n\t\n\t/**\n\t * @param {Array<string>} value\n\t * @return {Array<string>}\n\t */\n\tPattern.prototype.formatValue = function format(value) {\n\t  var valueBuffer = new Array(this.length)\n\t  var valueIndex = 0\n\t\n\t  for (var i = 0, l = this.length; i < l ; i++) {\n\t    if (this.isEditableIndex(i)) {\n\t      valueBuffer[i] = (value.length > valueIndex && this.isValidAtIndex(value[valueIndex], i)\n\t                        ? this.transform(value[valueIndex], i)\n\t                        : this.placeholderChar)\n\t      valueIndex++\n\t    }\n\t    else {\n\t      valueBuffer[i] = this.pattern[i]\n\t      // Also allow the value to contain static values from the pattern by\n\t      // advancing its index.\n\t      if (value.length > valueIndex && value[valueIndex] === this.pattern[i]) {\n\t        valueIndex++\n\t      }\n\t    }\n\t  }\n\t\n\t  return valueBuffer\n\t}\n\t\n\t/**\n\t * @param {number} index\n\t * @return {boolean}\n\t */\n\tPattern.prototype.isEditableIndex = function isEditableIndex(index) {\n\t  return !!this._editableIndices[index]\n\t}\n\t\n\t/**\n\t * @param {string} char\n\t * @param {number} index\n\t * @return {boolean}\n\t */\n\tPattern.prototype.isValidAtIndex = function isValidAtIndex(char, index) {\n\t  return this.formatCharacters[this.pattern[index]].validate(char)\n\t}\n\t\n\tPattern.prototype.transform = function transform(char, index) {\n\t  var format = this.formatCharacters[this.pattern[index]]\n\t  return typeof format.transform == 'function' ? format.transform(char) : char\n\t}\n\t\n\tfunction InputMask(options) {\n\t  if (!(this instanceof InputMask)) { return new InputMask(options) }\n\t\n\t  options = extend({\n\t    formatCharacters: null,\n\t    pattern: null,\n\t    placeholderChar: DEFAULT_PLACEHOLDER_CHAR,\n\t    selection: {start: 0, end: 0},\n\t    value: ''\n\t  }, options)\n\t\n\t  if (options.pattern == null) {\n\t    throw new Error('InputMask: you must provide a pattern.')\n\t  }\n\t\n\t  if (options.placeholderChar.length !== 1) {\n\t    throw new Error('InputMask: placeholderChar should be a single character.')\n\t  }\n\t\n\t  this.placeholderChar = options.placeholderChar\n\t  this.formatCharacters = mergeFormatCharacters(options.formatCharacters)\n\t  this.setPattern(options.pattern, {\n\t    value: options.value,\n\t    selection: options.selection\n\t  })\n\t}\n\t\n\t// Editing\n\t\n\t/**\n\t * Applies a single character of input based on the current selection.\n\t * @param {string} char\n\t * @return {boolean} true if a change has been made to value or selection as a\n\t *   result of the input, false otherwise.\n\t */\n\tInputMask.prototype.input = function input(char) {\n\t  // Ignore additional input if the cursor's at the end of the pattern\n\t  if (this.selection.start === this.selection.end &&\n\t      this.selection.start === this.pattern.length) {\n\t    return false\n\t  }\n\t\n\t  var selectionBefore = copy(this.selection)\n\t  var valueBefore = this.getValue()\n\t\n\t  var inputIndex = this.selection.start\n\t\n\t  // If the cursor or selection is prior to the first editable character, make\n\t  // sure any input given is applied to it.\n\t  if (inputIndex < this.pattern.firstEditableIndex) {\n\t    inputIndex = this.pattern.firstEditableIndex\n\t  }\n\t\n\t  // Bail out or add the character to input\n\t  if (this.pattern.isEditableIndex(inputIndex)) {\n\t    if (!this.pattern.isValidAtIndex(char, inputIndex)) {\n\t      return false\n\t    }\n\t    this.value[inputIndex] = this.pattern.transform(char, inputIndex)\n\t  }\n\t\n\t  // If multiple characters were selected, blank the remainder out based on the\n\t  // pattern.\n\t  var end = this.selection.end - 1\n\t  while (end > inputIndex) {\n\t    if (this.pattern.isEditableIndex(end)) {\n\t      this.value[end] = this.placeholderChar\n\t    }\n\t    end--\n\t  }\n\t\n\t  // Advance the cursor to the next character\n\t  this.selection.start = this.selection.end = inputIndex + 1\n\t\n\t  // Skip over any subsequent static characters\n\t  while (this.pattern.length > this.selection.start &&\n\t         !this.pattern.isEditableIndex(this.selection.start)) {\n\t    this.selection.start++\n\t    this.selection.end++\n\t  }\n\t\n\t  // History\n\t  if (this._historyIndex != null) {\n\t    // Took more input after undoing, so blow any subsequent history away\n\t    console.log('splice(', this._historyIndex, this._history.length - this._historyIndex, ')')\n\t    this._history.splice(this._historyIndex, this._history.length - this._historyIndex)\n\t    this._historyIndex = null\n\t  }\n\t  if (this._lastOp !== 'input' ||\n\t      selectionBefore.start !== selectionBefore.end ||\n\t      this._lastSelection !== null && selectionBefore.start !== this._lastSelection.start) {\n\t    this._history.push({value: valueBefore, selection: selectionBefore, lastOp: this._lastOp})\n\t  }\n\t  this._lastOp = 'input'\n\t  this._lastSelection = copy(this.selection)\n\t\n\t  return true\n\t}\n\t\n\t/**\n\t * Attempts to delete from the value based on the current cursor position or\n\t * selection.\n\t * @return {boolean} true if the value or selection changed as the result of\n\t *   backspacing, false otherwise.\n\t */\n\tInputMask.prototype.backspace = function backspace() {\n\t  // If the cursor is at the start there's nothing to do\n\t  if (this.selection.start === 0 && this.selection.end === 0) {\n\t    return false\n\t  }\n\t\n\t  var selectionBefore = copy(this.selection)\n\t  var valueBefore = this.getValue()\n\t\n\t  // No range selected - work on the character preceding the cursor\n\t  if (this.selection.start === this.selection.end) {\n\t    if (this.pattern.isEditableIndex(this.selection.start - 1)) {\n\t      this.value[this.selection.start - 1] = this.placeholderChar\n\t    }\n\t    this.selection.start--\n\t    this.selection.end--\n\t  }\n\t  // Range selected - delete characters and leave the cursor at the start of the selection\n\t  else {\n\t    var end = this.selection.end - 1\n\t    while (end >= this.selection.start) {\n\t      if (this.pattern.isEditableIndex(end)) {\n\t        this.value[end] = this.placeholderChar\n\t      }\n\t      end--\n\t    }\n\t    this.selection.end = this.selection.start\n\t  }\n\t\n\t  // History\n\t  if (this._historyIndex != null) {\n\t    // Took more input after undoing, so blow any subsequent history away\n\t    this._history.splice(this._historyIndex, this._history.length - this._historyIndex)\n\t  }\n\t  if (this._lastOp !== 'backspace' ||\n\t      selectionBefore.start !== selectionBefore.end ||\n\t      this._lastSelection !== null && selectionBefore.start !== this._lastSelection.start) {\n\t    this._history.push({value: valueBefore, selection: selectionBefore, lastOp: this._lastOp})\n\t  }\n\t  this._lastOp = 'backspace'\n\t  this._lastSelection = copy(this.selection)\n\t\n\t  return true\n\t}\n\t\n\t/**\n\t * Attempts to paste a string of input at the current cursor position or over\n\t * the top of the current selection.\n\t * Invalid content at any position will cause the paste to be rejected, and it\n\t * may contain static parts of the mask's pattern.\n\t * @param {string} input\n\t * @return {boolean} true if the paste was successful, false otherwise.\n\t */\n\tInputMask.prototype.paste = function paste(input) {\n\t  // This is necessary because we're just calling input() with each character\n\t  // and rolling back if any were invalid, rather than checking up-front.\n\t  var initialState = {\n\t    value: this.value.slice(),\n\t    selection: copy(this.selection),\n\t    _lastOp: this._lastOp,\n\t    _history: this._history.slice(),\n\t    _historyIndex: this._historyIndex,\n\t    _lastSelection: copy(this._lastSelection)\n\t  }\n\t\n\t  // If there are static characters at the start of the pattern and the cursor\n\t  // or selection is within them, the static characters must match for a valid\n\t  // paste.\n\t  if (this.selection.start < this.pattern.firstEditableIndex) {\n\t    for (var i = 0, l = this.pattern.firstEditableIndex - this.selection.start; i < l; i++) {\n\t      if (input.charAt(i) !== this.pattern.pattern[i]) {\n\t        return false\n\t      }\n\t    }\n\t\n\t    // Continue as if the selection and input started from the editable part of\n\t    // the pattern.\n\t    input = input.substring(this.pattern.firstEditableIndex - this.selection.start)\n\t    this.selection.start = this.pattern.firstEditableIndex\n\t  }\n\t\n\t  for (i = 0, l = input.length;\n\t       i < l && this.selection.start <= this.pattern.lastEditableIndex;\n\t       i++) {\n\t    var valid = this.input(input.charAt(i))\n\t    // Allow static parts of the pattern to appear in pasted input - they will\n\t    // already have been stepped over by input(), so verify that the value\n\t    // deemed invalid by input() was the expected static character.\n\t    if (!valid) {\n\t      if (this.selection.start > 0) {\n\t        // XXX This only allows for one static character to be skipped\n\t        var patternIndex = this.selection.start - 1\n\t        if (!this.pattern.isEditableIndex(patternIndex) &&\n\t            input.charAt(i) === this.pattern.pattern[patternIndex]) {\n\t          continue\n\t        }\n\t      }\n\t      extend(this, initialState)\n\t      return false\n\t    }\n\t  }\n\t\n\t  return true\n\t}\n\t\n\t// History\n\t\n\tInputMask.prototype.undo = function undo() {\n\t  // If there is no history, or nothing more on the history stack, we can't undo\n\t  if (this._history.length === 0 || this._historyIndex === 0) {\n\t    return false\n\t  }\n\t\n\t  var historyItem\n\t  if (this._historyIndex == null) {\n\t    // Not currently undoing, set up the initial history index\n\t    this._historyIndex = this._history.length - 1\n\t    historyItem = this._history[this._historyIndex]\n\t    // Add a new history entry if anything has changed since the last one, so we\n\t    // can redo back to the initial state we started undoing from.\n\t    var value = this.getValue()\n\t    if (historyItem.value !== value ||\n\t        historyItem.selection.start !== this.selection.start ||\n\t        historyItem.selection.end !== this.selection.end) {\n\t      this._history.push({value: value, selection: copy(this.selection), lastOp: this._lastOp, startUndo: true})\n\t    }\n\t  }\n\t  else {\n\t    historyItem = this._history[--this._historyIndex]\n\t  }\n\t\n\t  this.value = historyItem.value.split('')\n\t  this.selection = historyItem.selection\n\t  this._lastOp = historyItem.lastOp\n\t  return true\n\t}\n\t\n\tInputMask.prototype.redo = function redo() {\n\t  if (this._history.length === 0 || this._historyIndex == null) {\n\t    return false\n\t  }\n\t  var historyItem = this._history[++this._historyIndex]\n\t  // If this is the last history item, we're done redoing\n\t  if (this._historyIndex === this._history.length - 1) {\n\t    this._historyIndex = null\n\t    // If the last history item was only added to start undoing, remove it\n\t    if (historyItem.startUndo) {\n\t      this._history.pop()\n\t    }\n\t  }\n\t  this.value = historyItem.value.split('')\n\t  this.selection = historyItem.selection\n\t  this._lastOp = historyItem.lastOp\n\t  return true\n\t}\n\t\n\t// Getters & setters\n\t\n\tInputMask.prototype.setPattern = function setPattern(pattern, options) {\n\t  options = extend({\n\t    selection: {start: 0, end: 0},\n\t    value: ''\n\t  }, options)\n\t  this.pattern = new Pattern(pattern, this.formatCharacters, this.placeholderChar)\n\t  this.setValue(options.value)\n\t  this.emptyValue = this.pattern.formatValue([]).join('')\n\t  this.selection = options.selection\n\t  this._resetHistory()\n\t}\n\t\n\tInputMask.prototype.setSelection = function setSelection(selection) {\n\t  this.selection = copy(selection)\n\t  if (this.selection.start === this.selection.end) {\n\t    if (this.selection.start < this.pattern.firstEditableIndex) {\n\t      this.selection.start = this.selection.end = this.pattern.firstEditableIndex\n\t      return true\n\t    }\n\t    if (this.selection.end > this.pattern.lastEditableIndex + 1) {\n\t      this.selection.start = this.selection.end = this.pattern.lastEditableIndex + 1\n\t      return true\n\t    }\n\t  }\n\t  return false\n\t}\n\t\n\tInputMask.prototype.setValue = function setValue(value) {\n\t  if (value == null) {\n\t    value = ''\n\t  }\n\t  this.value = this.pattern.formatValue(value.split(''))\n\t}\n\t\n\tInputMask.prototype.getValue = function getValue() {\n\t  return this.value.join('')\n\t}\n\t\n\tInputMask.prototype.getRawValue = function getRawValue() {\n\t  var rawValue = []\n\t  for (var i = 0; i < this.value.length; i++) {\n\t    if (this.pattern._editableIndices[i] === true) {\n\t      rawValue.push(this.value[i])\n\t    }\n\t  }\n\t  return rawValue.join('')\n\t}\n\t\n\tInputMask.prototype._resetHistory = function _resetHistory() {\n\t  this._history = []\n\t  this._historyIndex = null\n\t  this._lastOp = null\n\t  this._lastSelection = copy(this.selection)\n\t}\n\t\n\tInputMask.Pattern = Pattern\n\t\n\tmodule.exports = InputMask\n\n\n/***/ },\n/* 8 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * Copyright 2013-present, Facebook, Inc.\n\t * All rights reserved.\n\t *\n\t * This source code is licensed under the BSD-style license found in the\n\t * LICENSE file in the root directory of this source tree. An additional grant\n\t * of patent rights can be found in the PATENTS file in the same directory.\n\t *\n\t * @providesModule ReactDOMSelection\n\t */\n\t\n\t'use strict';\n\t\n\tvar ExecutionEnvironment = __webpack_require__(1);\n\t\n\tvar getNodeForCharacterOffset = __webpack_require__(10);\n\tvar getTextContentAccessor = __webpack_require__(11);\n\t\n\t/**\n\t * While `isCollapsed` is available on the Selection object and `collapsed`\n\t * is available on the Range object, IE11 sometimes gets them wrong.\n\t * If the anchor/focus nodes and offsets are the same, the range is collapsed.\n\t */\n\tfunction isCollapsed(anchorNode, anchorOffset, focusNode, focusOffset) {\n\t  return anchorNode === focusNode && anchorOffset === focusOffset;\n\t}\n\t\n\t/**\n\t * Get the appropriate anchor and focus node/offset pairs for IE.\n\t *\n\t * The catch here is that IE's selection API doesn't provide information\n\t * about whether the selection is forward or backward, so we have to\n\t * behave as though it's always forward.\n\t *\n\t * IE text differs from modern selection in that it behaves as though\n\t * block elements end with a new line. This means character offsets will\n\t * differ between the two APIs.\n\t *\n\t * @param {DOMElement} node\n\t * @return {object}\n\t */\n\tfunction getIEOffsets(node) {\n\t  var selection = document.selection;\n\t  var selectedRange = selection.createRange();\n\t  var selectedLength = selectedRange.text.length;\n\t\n\t  // Duplicate selection so we can move range without breaking user selection.\n\t  var fromStart = selectedRange.duplicate();\n\t  fromStart.moveToElementText(node);\n\t  fromStart.setEndPoint('EndToStart', selectedRange);\n\t\n\t  var startOffset = fromStart.text.length;\n\t  var endOffset = startOffset + selectedLength;\n\t\n\t  return {\n\t    start: startOffset,\n\t    end: endOffset\n\t  };\n\t}\n\t\n\t/**\n\t * @param {DOMElement} node\n\t * @return {?object}\n\t */\n\tfunction getModernOffsets(node) {\n\t  var selection = window.getSelection && window.getSelection();\n\t\n\t  if (!selection || selection.rangeCount === 0) {\n\t    return null;\n\t  }\n\t\n\t  var anchorNode = selection.anchorNode;\n\t  var anchorOffset = selection.anchorOffset;\n\t  var focusNode = selection.focusNode;\n\t  var focusOffset = selection.focusOffset;\n\t\n\t  var currentRange = selection.getRangeAt(0);\n\t\n\t  // In Firefox, range.startContainer and range.endContainer can be \"anonymous\n\t  // divs\", e.g. the up/down buttons on an <input type=\"number\">. Anonymous\n\t  // divs do not seem to expose properties, triggering a \"Permission denied\n\t  // error\" if any of its properties are accessed. The only seemingly possible\n\t  // way to avoid erroring is to access a property that typically works for\n\t  // non-anonymous divs and catch any error that may otherwise arise. See\n\t  // https://bugzilla.mozilla.org/show_bug.cgi?id=208427\n\t  try {\n\t    /* eslint-disable no-unused-expressions */\n\t    currentRange.startContainer.nodeType;\n\t    currentRange.endContainer.nodeType;\n\t    /* eslint-enable no-unused-expressions */\n\t  } catch (e) {\n\t    return null;\n\t  }\n\t\n\t  // If the node and offset values are the same, the selection is collapsed.\n\t  // `Selection.isCollapsed` is available natively, but IE sometimes gets\n\t  // this value wrong.\n\t  var isSelectionCollapsed = isCollapsed(selection.anchorNode, selection.anchorOffset, selection.focusNode, selection.focusOffset);\n\t\n\t  var rangeLength = isSelectionCollapsed ? 0 : currentRange.toString().length;\n\t\n\t  var tempRange = currentRange.cloneRange();\n\t  tempRange.selectNodeContents(node);\n\t  tempRange.setEnd(currentRange.startContainer, currentRange.startOffset);\n\t\n\t  var isTempRangeCollapsed = isCollapsed(tempRange.startContainer, tempRange.startOffset, tempRange.endContainer, tempRange.endOffset);\n\t\n\t  var start = isTempRangeCollapsed ? 0 : tempRange.toString().length;\n\t  var end = start + rangeLength;\n\t\n\t  // Detect whether the selection is backward.\n\t  var detectionRange = document.createRange();\n\t  detectionRange.setStart(anchorNode, anchorOffset);\n\t  detectionRange.setEnd(focusNode, focusOffset);\n\t  var isBackward = detectionRange.collapsed;\n\t\n\t  return {\n\t    start: isBackward ? end : start,\n\t    end: isBackward ? start : end\n\t  };\n\t}\n\t\n\t/**\n\t * @param {DOMElement|DOMTextNode} node\n\t * @param {object} offsets\n\t */\n\tfunction setIEOffsets(node, offsets) {\n\t  var range = document.selection.createRange().duplicate();\n\t  var start, end;\n\t\n\t  if (offsets.end === undefined) {\n\t    start = offsets.start;\n\t    end = start;\n\t  } else if (offsets.start > offsets.end) {\n\t    start = offsets.end;\n\t    end = offsets.start;\n\t  } else {\n\t    start = offsets.start;\n\t    end = offsets.end;\n\t  }\n\t\n\t  range.moveToElementText(node);\n\t  range.moveStart('character', start);\n\t  range.setEndPoint('EndToStart', range);\n\t  range.moveEnd('character', end - start);\n\t  range.select();\n\t}\n\t\n\t/**\n\t * In modern non-IE browsers, we can support both forward and backward\n\t * selections.\n\t *\n\t * Note: IE10+ supports the Selection object, but it does not support\n\t * the `extend` method, which means that even in modern IE, it's not possible\n\t * to programmatically create a backward selection. Thus, for all IE\n\t * versions, we use the old IE API to create our selections.\n\t *\n\t * @param {DOMElement|DOMTextNode} node\n\t * @param {object} offsets\n\t */\n\tfunction setModernOffsets(node, offsets) {\n\t  if (!window.getSelection) {\n\t    return;\n\t  }\n\t\n\t  var selection = window.getSelection();\n\t  var length = node[getTextContentAccessor()].length;\n\t  var start = Math.min(offsets.start, length);\n\t  var end = offsets.end === undefined ? start : Math.min(offsets.end, length);\n\t\n\t  // IE 11 uses modern selection, but doesn't support the extend method.\n\t  // Flip backward selections, so we can set with a single range.\n\t  if (!selection.extend && start > end) {\n\t    var temp = end;\n\t    end = start;\n\t    start = temp;\n\t  }\n\t\n\t  var startMarker = getNodeForCharacterOffset(node, start);\n\t  var endMarker = getNodeForCharacterOffset(node, end);\n\t\n\t  if (startMarker && endMarker) {\n\t    var range = document.createRange();\n\t    range.setStart(startMarker.node, startMarker.offset);\n\t    selection.removeAllRanges();\n\t\n\t    if (start > end) {\n\t      selection.addRange(range);\n\t      selection.extend(endMarker.node, endMarker.offset);\n\t    } else {\n\t      range.setEnd(endMarker.node, endMarker.offset);\n\t      selection.addRange(range);\n\t    }\n\t  }\n\t}\n\t\n\tvar useIEOffsets = ExecutionEnvironment.canUseDOM && 'selection' in document && !('getSelection' in window);\n\t\n\tvar ReactDOMSelection = {\n\t  /**\n\t   * @param {DOMElement} node\n\t   */\n\t  getOffsets: useIEOffsets ? getIEOffsets : getModernOffsets,\n\t\n\t  /**\n\t   * @param {DOMElement|DOMTextNode} node\n\t   * @param {object} offsets\n\t   */\n\t  setOffsets: useIEOffsets ? setIEOffsets : setModernOffsets\n\t};\n\t\n\tmodule.exports = ReactDOMSelection;\n\n/***/ },\n/* 9 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * Copyright 2013-present, Facebook, Inc.\n\t * All rights reserved.\n\t *\n\t * This source code is licensed under the BSD-style license found in the\n\t * LICENSE file in the root directory of this source tree. An additional grant\n\t * of patent rights can be found in the PATENTS file in the same directory.\n\t *\n\t * @providesModule ReactInputSelection\n\t */\n\t\n\t'use strict';\n\t\n\tvar ReactDOMSelection = __webpack_require__(8);\n\t\n\tvar containsNode = __webpack_require__(2);\n\tvar focusNode = __webpack_require__(3);\n\tvar getActiveElement = __webpack_require__(4);\n\t\n\tfunction isInDocument(node) {\n\t  return containsNode(document.documentElement, node);\n\t}\n\t\n\t/**\n\t * @ReactInputSelection: React input selection module. Based on Selection.js,\n\t * but modified to be suitable for react and has a couple of bug fixes (doesn't\n\t * assume buttons have range selections allowed).\n\t * Input selection module for React.\n\t */\n\tvar ReactInputSelection = {\n\t\n\t  hasSelectionCapabilities: function (elem) {\n\t    var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();\n\t    return nodeName && (nodeName === 'input' && elem.type === 'text' || nodeName === 'textarea' || elem.contentEditable === 'true');\n\t  },\n\t\n\t  getSelectionInformation: function () {\n\t    var focusedElem = getActiveElement();\n\t    return {\n\t      focusedElem: focusedElem,\n\t      selectionRange: ReactInputSelection.hasSelectionCapabilities(focusedElem) ? ReactInputSelection.getSelection(focusedElem) : null\n\t    };\n\t  },\n\t\n\t  /**\n\t   * @restoreSelection: If any selection information was potentially lost,\n\t   * restore it. This is useful when performing operations that could remove dom\n\t   * nodes and place them back in, resulting in focus being lost.\n\t   */\n\t  restoreSelection: function (priorSelectionInformation) {\n\t    var curFocusedElem = getActiveElement();\n\t    var priorFocusedElem = priorSelectionInformation.focusedElem;\n\t    var priorSelectionRange = priorSelectionInformation.selectionRange;\n\t    if (curFocusedElem !== priorFocusedElem && isInDocument(priorFocusedElem)) {\n\t      if (ReactInputSelection.hasSelectionCapabilities(priorFocusedElem)) {\n\t        ReactInputSelection.setSelection(priorFocusedElem, priorSelectionRange);\n\t      }\n\t      focusNode(priorFocusedElem);\n\t    }\n\t  },\n\t\n\t  /**\n\t   * @getSelection: Gets the selection bounds of a focused textarea, input or\n\t   * contentEditable node.\n\t   * -@input: Look up selection bounds of this input\n\t   * -@return {start: selectionStart, end: selectionEnd}\n\t   */\n\t  getSelection: function (input) {\n\t    var selection;\n\t\n\t    if ('selectionStart' in input) {\n\t      // Modern browser with input or textarea.\n\t      selection = {\n\t        start: input.selectionStart,\n\t        end: input.selectionEnd\n\t      };\n\t    } else if (document.selection && input.nodeName && input.nodeName.toLowerCase() === 'input') {\n\t      // IE8 input.\n\t      var range = document.selection.createRange();\n\t      // There can only be one selection per document in IE, so it must\n\t      // be in our element.\n\t      if (range.parentElement() === input) {\n\t        selection = {\n\t          start: -range.moveStart('character', -input.value.length),\n\t          end: -range.moveEnd('character', -input.value.length)\n\t        };\n\t      }\n\t    } else {\n\t      // Content editable or old IE textarea.\n\t      selection = ReactDOMSelection.getOffsets(input);\n\t    }\n\t\n\t    return selection || { start: 0, end: 0 };\n\t  },\n\t\n\t  /**\n\t   * @setSelection: Sets the selection bounds of a textarea or input and focuses\n\t   * the input.\n\t   * -@input     Set selection bounds of this input or textarea\n\t   * -@offsets   Object of same form that is returned from get*\n\t   */\n\t  setSelection: function (input, offsets) {\n\t    var start = offsets.start;\n\t    var end = offsets.end;\n\t    if (end === undefined) {\n\t      end = start;\n\t    }\n\t\n\t    if ('selectionStart' in input) {\n\t      input.selectionStart = start;\n\t      input.selectionEnd = Math.min(end, input.value.length);\n\t    } else if (document.selection && input.nodeName && input.nodeName.toLowerCase() === 'input') {\n\t      var range = input.createTextRange();\n\t      range.collapse(true);\n\t      range.moveStart('character', start);\n\t      range.moveEnd('character', end - start);\n\t      range.select();\n\t    } else {\n\t      ReactDOMSelection.setOffsets(input, offsets);\n\t    }\n\t  }\n\t};\n\t\n\tmodule.exports = ReactInputSelection;\n\n/***/ },\n/* 10 */\n/***/ function(module, exports) {\n\n\t/**\n\t * Copyright 2013-present, Facebook, Inc.\n\t * All rights reserved.\n\t *\n\t * This source code is licensed under the BSD-style license found in the\n\t * LICENSE file in the root directory of this source tree. An additional grant\n\t * of patent rights can be found in the PATENTS file in the same directory.\n\t *\n\t * @providesModule getNodeForCharacterOffset\n\t */\n\t\n\t'use strict';\n\t\n\t/**\n\t * Given any node return the first leaf node without children.\n\t *\n\t * @param {DOMElement|DOMTextNode} node\n\t * @return {DOMElement|DOMTextNode}\n\t */\n\t\n\tfunction getLeafNode(node) {\n\t  while (node && node.firstChild) {\n\t    node = node.firstChild;\n\t  }\n\t  return node;\n\t}\n\t\n\t/**\n\t * Get the next sibling within a container. This will walk up the\n\t * DOM if a node's siblings have been exhausted.\n\t *\n\t * @param {DOMElement|DOMTextNode} node\n\t * @return {?DOMElement|DOMTextNode}\n\t */\n\tfunction getSiblingNode(node) {\n\t  while (node) {\n\t    if (node.nextSibling) {\n\t      return node.nextSibling;\n\t    }\n\t    node = node.parentNode;\n\t  }\n\t}\n\t\n\t/**\n\t * Get object describing the nodes which contain characters at offset.\n\t *\n\t * @param {DOMElement|DOMTextNode} root\n\t * @param {number} offset\n\t * @return {?object}\n\t */\n\tfunction getNodeForCharacterOffset(root, offset) {\n\t  var node = getLeafNode(root);\n\t  var nodeStart = 0;\n\t  var nodeEnd = 0;\n\t\n\t  while (node) {\n\t    if (node.nodeType === 3) {\n\t      nodeEnd = nodeStart + node.textContent.length;\n\t\n\t      if (nodeStart <= offset && nodeEnd >= offset) {\n\t        return {\n\t          node: node,\n\t          offset: offset - nodeStart\n\t        };\n\t      }\n\t\n\t      nodeStart = nodeEnd;\n\t    }\n\t\n\t    node = getLeafNode(getSiblingNode(node));\n\t  }\n\t}\n\t\n\tmodule.exports = getNodeForCharacterOffset;\n\n/***/ },\n/* 11 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * Copyright 2013-present, Facebook, Inc.\n\t * All rights reserved.\n\t *\n\t * This source code is licensed under the BSD-style license found in the\n\t * LICENSE file in the root directory of this source tree. An additional grant\n\t * of patent rights can be found in the PATENTS file in the same directory.\n\t *\n\t * @providesModule getTextContentAccessor\n\t */\n\t\n\t'use strict';\n\t\n\tvar ExecutionEnvironment = __webpack_require__(1);\n\t\n\tvar contentKey = null;\n\t\n\t/**\n\t * Gets the key used to access text content on a DOM node.\n\t *\n\t * @return {?string} Key used to access text content.\n\t * @internal\n\t */\n\tfunction getTextContentAccessor() {\n\t  if (!contentKey && ExecutionEnvironment.canUseDOM) {\n\t    // Prefer textContent to innerText because many browsers support both but\n\t    // SVG <text> elements don't support innerText even when <div> does.\n\t    contentKey = 'textContent' in document.documentElement ? 'textContent' : 'innerText';\n\t  }\n\t  return contentKey;\n\t}\n\t\n\tmodule.exports = getTextContentAccessor;\n\n/***/ },\n/* 12 */\n/***/ function(module, exports) {\n\n\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_12__;\n\n/***/ }\n/******/ ])\n});\n;\n\n\n/** WEBPACK FOOTER **\n ** react-maskedinput.min.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 4682262fdc5538e1e53d\n **/","var React = require('react')\nvar {getSelection, setSelection} = require('react/lib/ReactInputSelection')\n\nvar InputMask = require('inputmask-core')\n\nvar KEYCODE_Z = 90\nvar KEYCODE_Y = 89\n\nfunction isUndo(e) {\n  return (e.ctrlKey || e.metaKey) && e.keyCode === (e.shiftKey ? KEYCODE_Y : KEYCODE_Z)\n}\n\nfunction isRedo(e) {\n  return (e.ctrlKey || e.metaKey) && e.keyCode === (e.shiftKey ? KEYCODE_Z : KEYCODE_Y)\n}\n\nvar MaskedInput = React.createClass({\n  propTypes: {\n    mask: React.PropTypes.string.isRequired,\n\n    formatCharacters: React.PropTypes.object,\n    placeholderChar: React.PropTypes.string\n  },\n\n  getDefaultProps() {\n    return {\n      value: ''\n    }\n  },\n\n  componentWillMount() {\n    var options = {\n      pattern: this.props.mask,\n      value: this.props.value,\n      formatCharacters: this.props.formatCharacters\n    }\n    if (this.props.placeholderChar) {\n      options.placeholderChar = this.props.placeholderChar\n    }\n    this.mask = new InputMask(options)\n  },\n\n  componentWillReceiveProps(nextProps) {\n    // update the pattern first to avoid left over placeholders\n    if (this.props.mask !== nextProps.mask) {\n      this.mask.setPattern(nextProps.mask, {value: this.mask.getRawValue()})\n    }\n    if (this.props.value !== nextProps.value) {\n      this.mask.setValue(nextProps.value)\n    }\n  },\n\n  componentWillUpdate(nextProps, nextState) {\n    if (nextProps.mask !== this.props.mask) {\n      this._updatePattern(nextProps)\n    }\n  },\n\n  componentDidUpdate(prevProps) {\n    if (prevProps.mask !== this.props.mask && this.mask.selection.start) {\n      this._updateInputSelection()\n    }\n  },\n\n  _updatePattern: function(props) {\n    this.mask.setPattern(props.mask, {\n      value: this.mask.getRawValue(),\n      selection: getSelection(this.input)\n    })\n  },\n\n  _updateMaskSelection() {\n    this.mask.selection = getSelection(this.input)\n  },\n\n  _updateInputSelection() {\n    setSelection(this.input, this.mask.selection)\n  },\n\n  _onChange(e) {\n    // console.log('onChange', JSON.stringify(getSelection(this.input)), e.target.value)\n\n    var maskValue = this.mask.getValue()\n    if (e.target.value !== maskValue) {\n      // Cut or delete operations will have shortened the value\n      if (e.target.value.length < maskValue.length) {\n        var sizeDiff = maskValue.length - e.target.value.length\n        this._updateMaskSelection()\n        this.mask.selection.end = this.mask.selection.start + sizeDiff\n        this.mask.backspace()\n      }\n      else {\n        this.mask.setValue(e.target.value)\n      }\n      var value = this._getDisplayValue()\n      e.target.value = value\n      if (value) {\n        this._updateInputSelection()\n      }\n    }\n    if (this.props.onChange) {\n      this.props.onChange(e)\n    }\n  },\n\n  _onKeyDown(e) {\n    // console.log('onKeyDown', JSON.stringify(getSelection(this.input)), e.key, e.target.value)\n\n    if (isUndo(e)) {\n      e.preventDefault()\n      if (this.mask.undo()) {\n        e.target.value = this._getDisplayValue()\n        this._updateInputSelection()\n        if (this.props.onChange) {\n          this.props.onChange(e)\n        }\n      }\n      return\n    }\n    else if (isRedo(e)) {\n      e.preventDefault()\n      if (this.mask.redo()) {\n        e.target.value = this._getDisplayValue()\n        this._updateInputSelection()\n        if (this.props.onChange) {\n          this.props.onChange(e)\n        }\n      }\n      return\n    }\n\n    if (e.key === 'Backspace') {\n      e.preventDefault()\n      this._updateMaskSelection()\n      if (this.mask.backspace()) {\n        var value = this._getDisplayValue()\n        e.target.value = value\n        if (value) {\n          this._updateInputSelection()\n        }\n        if (this.props.onChange) {\n          this.props.onChange(e)\n        }\n      }\n    }\n  },\n\n  _onKeyPress(e) {\n    // console.log('onKeyPress', JSON.stringify(getSelection(this.input)), e.key, e.target.value)\n\n    // Ignore modified key presses\n    // Ignore enter key to allow form submission\n    if (e.metaKey || e.altKey || e.ctrlKey || e.key === 'Enter') { return }\n\n    e.preventDefault()\n    this._updateMaskSelection()\n    if (this.mask.input(e.key)) {\n      e.target.value = this.mask.getValue()\n      this._updateInputSelection()\n      if (this.props.onChange) {\n        this.props.onChange(e)\n      }\n    }\n  },\n\n  _onPaste(e) {\n    // console.log('onPaste', JSON.stringify(getSelection(this.input)), e.clipboardData.getData('Text'), e.target.value)\n\n    e.preventDefault()\n    this._updateMaskSelection()\n    // getData value needed for IE also works in FF & Chrome\n    if (this.mask.paste(e.clipboardData.getData('Text'))) {\n      e.target.value = this.mask.getValue()\n      // Timeout needed for IE\n      setTimeout(this._updateInputSelection, 0)\n      if (this.props.onChange) {\n        this.props.onChange(e)\n      }\n    }\n  },\n\n  _getDisplayValue() {\n    var value = this.mask.getValue()\n    return value === this.mask.emptyValue ? '' : value\n  },\n\n  focus() {\n    this.input.focus()\n  },\n\n  blur() {\n    this.input.blur()\n  },\n\n  render() {\n    var {mask, formatCharacters, size, placeholder, placeholderChar, ...props} = this.props\n    var patternLength = this.mask.pattern.length\n    return <input {...props}\n      ref={r => this.input = r }\n      maxLength={patternLength}\n      onChange={this._onChange}\n      onKeyDown={this._onKeyDown}\n      onKeyPress={this._onKeyPress}\n      onPaste={this._onPaste}\n      placeholder={placeholder || this.mask.emptyValue}\n      size={size || patternLength}\n      value={this._getDisplayValue()}\n    />\n  }\n})\n\nmodule.exports = MaskedInput\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/index.js\n **/","/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n */\n\n'use strict';\n\nvar canUseDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);\n\n/**\n * Simple, lightweight module assisting with the detection and context of\n * Worker. Helps avoid circular dependencies and allows code to reason about\n * whether or not they are in a Worker, even if they never include the main\n * `ReactWorker` dependency.\n */\nvar ExecutionEnvironment = {\n\n  canUseDOM: canUseDOM,\n\n  canUseWorkers: typeof Worker !== 'undefined',\n\n  canUseEventListeners: canUseDOM && !!(window.addEventListener || window.attachEvent),\n\n  canUseViewport: canUseDOM && !!window.screen,\n\n  isInWorker: !canUseDOM // For now, this is true - might change in the future.\n\n};\n\nmodule.exports = ExecutionEnvironment;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/fbjs/lib/ExecutionEnvironment.js\n ** module id = 1\n ** module chunks = 0\n **/","'use strict';\n\n/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * \n */\n\nvar isTextNode = require('./isTextNode');\n\n/*eslint-disable no-bitwise */\n\n/**\n * Checks if a given DOM node contains or is another DOM node.\n */\nfunction containsNode(outerNode, innerNode) {\n  if (!outerNode || !innerNode) {\n    return false;\n  } else if (outerNode === innerNode) {\n    return true;\n  } else if (isTextNode(outerNode)) {\n    return false;\n  } else if (isTextNode(innerNode)) {\n    return containsNode(outerNode, innerNode.parentNode);\n  } else if ('contains' in outerNode) {\n    return outerNode.contains(innerNode);\n  } else if (outerNode.compareDocumentPosition) {\n    return !!(outerNode.compareDocumentPosition(innerNode) & 16);\n  } else {\n    return false;\n  }\n}\n\nmodule.exports = containsNode;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/fbjs/lib/containsNode.js\n ** module id = 2\n ** module chunks = 0\n **/","/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n */\n\n'use strict';\n\n/**\n * @param {DOMElement} node input/textarea to focus\n */\n\nfunction focusNode(node) {\n  // IE8 can throw \"Can't move focus to the control because it is invisible,\n  // not enabled, or of a type that does not accept the focus.\" for all kinds of\n  // reasons that are too expensive and fragile to test.\n  try {\n    node.focus();\n  } catch (e) {}\n}\n\nmodule.exports = focusNode;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/fbjs/lib/focusNode.js\n ** module id = 3\n ** module chunks = 0\n **/","'use strict';\n\n/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @typechecks\n */\n\n/* eslint-disable fb-www/typeof-undefined */\n\n/**\n * Same as document.activeElement but wraps in a try-catch block. In IE it is\n * not safe to call document.activeElement if there is nothing focused.\n *\n * The activeElement will be null only if the document or document body is not\n * yet defined.\n */\nfunction getActiveElement() /*?DOMElement*/{\n  if (typeof document === 'undefined') {\n    return null;\n  }\n  try {\n    return document.activeElement || document.body;\n  } catch (e) {\n    return document.body;\n  }\n}\n\nmodule.exports = getActiveElement;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/fbjs/lib/getActiveElement.js\n ** module id = 4\n ** module chunks = 0\n **/","'use strict';\n\n/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @typechecks\n */\n\n/**\n * @param {*} object The object to check.\n * @return {boolean} Whether or not the object is a DOM node.\n */\nfunction isNode(object) {\n  return !!(object && (typeof Node === 'function' ? object instanceof Node : typeof object === 'object' && typeof object.nodeType === 'number' && typeof object.nodeName === 'string'));\n}\n\nmodule.exports = isNode;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/fbjs/lib/isNode.js\n ** module id = 5\n ** module chunks = 0\n **/","'use strict';\n\n/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @typechecks\n */\n\nvar isNode = require('./isNode');\n\n/**\n * @param {*} object The object to check.\n * @return {boolean} Whether or not the object is a DOM text node.\n */\nfunction isTextNode(object) {\n  return isNode(object) && object.nodeType == 3;\n}\n\nmodule.exports = isTextNode;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/fbjs/lib/isTextNode.js\n ** module id = 6\n ** module chunks = 0\n **/","'use strict'\n\nfunction extend(dest, src) {\n  if (src) {\n    var props = Object.keys(src)\n    for (var i = 0, l = props.length; i < l ; i++) {\n      dest[props[i]] = src[props[i]]\n    }\n  }\n  return dest\n}\n\nfunction copy(obj) {\n  return extend({}, obj)\n}\n\n/**\n * Merge an object defining format characters into the defaults.\n * Passing null/undefined for en existing format character removes it.\n * Passing a definition for an existing format character overrides it.\n * @param {?Object} formatCharacters.\n */\nfunction mergeFormatCharacters(formatCharacters) {\n  var merged = copy(DEFAULT_FORMAT_CHARACTERS)\n  if (formatCharacters) {\n    var chars = Object.keys(formatCharacters)\n    for (var i = 0, l = chars.length; i < l ; i++) {\n      var char = chars[i]\n      if (formatCharacters[char] == null) {\n        delete merged[char]\n      }\n      else {\n        merged[char] = formatCharacters[char]\n      }\n    }\n  }\n  return merged\n}\n\nvar ESCAPE_CHAR = '\\\\'\n\nvar DIGIT_RE = /^\\d$/\nvar LETTER_RE = /^[A-Za-z]$/\nvar ALPHANNUMERIC_RE = /^[\\dA-Za-z]$/\n\nvar DEFAULT_PLACEHOLDER_CHAR = '_'\nvar DEFAULT_FORMAT_CHARACTERS = {\n  '*': {\n    validate: function(char) { return ALPHANNUMERIC_RE.test(char) }\n  },\n  '1': {\n    validate: function(char) { return DIGIT_RE.test(char) }\n  },\n  'a': {\n    validate: function(char) { return LETTER_RE.test(char) }\n  },\n  'A': {\n    validate: function(char) { return LETTER_RE.test(char) },\n    transform: function(char) { return char.toUpperCase() }\n  },\n  '#': {\n    validate: function(char) { return ALPHANNUMERIC_RE.test(char) },\n    transform: function(char) { return char.toUpperCase() }\n  }\n}\n\n/**\n * @param {string} source\n * @patam {?Object} formatCharacters\n */\nfunction Pattern(source, formatCharacters, placeholderChar) {\n  if (!(this instanceof Pattern)) {\n    return new Pattern(source, formatCharacters, placeholderChar)\n  }\n\n  /** Placeholder character */\n  this.placeholderChar = placeholderChar || DEFAULT_PLACEHOLDER_CHAR\n  /** Format character definitions. */\n  this.formatCharacters = formatCharacters || DEFAULT_FORMAT_CHARACTERS\n  /** Pattern definition string with escape characters. */\n  this.source = source\n  /** Pattern characters after escape characters have been processed. */\n  this.pattern = []\n  /** Length of the pattern after escape characters have been processed. */\n  this.length = 0\n  /** Index of the first editable character. */\n  this.firstEditableIndex = null\n  /** Index of the last editable character. */\n  this.lastEditableIndex = null\n\n  /** Lookup for indices of editable characters in the pattern. */\n  this._editableIndices = {}\n\n  this._parse()\n}\n\nPattern.prototype._parse = function parse() {\n  var sourceChars = this.source.split('')\n  var patternIndex = 0\n  var pattern = []\n\n  for (var i = 0, l = sourceChars.length; i < l; i++) {\n    var char = sourceChars[i]\n    if (char === ESCAPE_CHAR) {\n      if (i === l - 1) {\n        throw new Error('InputMask: pattern ends with a raw ' + ESCAPE_CHAR)\n      }\n      char = sourceChars[++i]\n    }\n    else if (char in this.formatCharacters) {\n      if (this.firstEditableIndex === null) {\n        this.firstEditableIndex = patternIndex\n      }\n      this.lastEditableIndex = patternIndex\n      this._editableIndices[patternIndex] = true\n    }\n\n    pattern.push(char)\n    patternIndex++\n  }\n\n  if (this.firstEditableIndex === null) {\n    throw new Error(\n      'InputMask: pattern \"' + this.source + '\" does not contain any editable characters.'\n    )\n  }\n\n  this.pattern = pattern\n  this.length = pattern.length\n}\n\n/**\n * @param {Array<string>} value\n * @return {Array<string>}\n */\nPattern.prototype.formatValue = function format(value) {\n  var valueBuffer = new Array(this.length)\n  var valueIndex = 0\n\n  for (var i = 0, l = this.length; i < l ; i++) {\n    if (this.isEditableIndex(i)) {\n      valueBuffer[i] = (value.length > valueIndex && this.isValidAtIndex(value[valueIndex], i)\n                        ? this.transform(value[valueIndex], i)\n                        : this.placeholderChar)\n      valueIndex++\n    }\n    else {\n      valueBuffer[i] = this.pattern[i]\n      // Also allow the value to contain static values from the pattern by\n      // advancing its index.\n      if (value.length > valueIndex && value[valueIndex] === this.pattern[i]) {\n        valueIndex++\n      }\n    }\n  }\n\n  return valueBuffer\n}\n\n/**\n * @param {number} index\n * @return {boolean}\n */\nPattern.prototype.isEditableIndex = function isEditableIndex(index) {\n  return !!this._editableIndices[index]\n}\n\n/**\n * @param {string} char\n * @param {number} index\n * @return {boolean}\n */\nPattern.prototype.isValidAtIndex = function isValidAtIndex(char, index) {\n  return this.formatCharacters[this.pattern[index]].validate(char)\n}\n\nPattern.prototype.transform = function transform(char, index) {\n  var format = this.formatCharacters[this.pattern[index]]\n  return typeof format.transform == 'function' ? format.transform(char) : char\n}\n\nfunction InputMask(options) {\n  if (!(this instanceof InputMask)) { return new InputMask(options) }\n\n  options = extend({\n    formatCharacters: null,\n    pattern: null,\n    placeholderChar: DEFAULT_PLACEHOLDER_CHAR,\n    selection: {start: 0, end: 0},\n    value: ''\n  }, options)\n\n  if (options.pattern == null) {\n    throw new Error('InputMask: you must provide a pattern.')\n  }\n\n  if (options.placeholderChar.length !== 1) {\n    throw new Error('InputMask: placeholderChar should be a single character.')\n  }\n\n  this.placeholderChar = options.placeholderChar\n  this.formatCharacters = mergeFormatCharacters(options.formatCharacters)\n  this.setPattern(options.pattern, {\n    value: options.value,\n    selection: options.selection\n  })\n}\n\n// Editing\n\n/**\n * Applies a single character of input based on the current selection.\n * @param {string} char\n * @return {boolean} true if a change has been made to value or selection as a\n *   result of the input, false otherwise.\n */\nInputMask.prototype.input = function input(char) {\n  // Ignore additional input if the cursor's at the end of the pattern\n  if (this.selection.start === this.selection.end &&\n      this.selection.start === this.pattern.length) {\n    return false\n  }\n\n  var selectionBefore = copy(this.selection)\n  var valueBefore = this.getValue()\n\n  var inputIndex = this.selection.start\n\n  // If the cursor or selection is prior to the first editable character, make\n  // sure any input given is applied to it.\n  if (inputIndex < this.pattern.firstEditableIndex) {\n    inputIndex = this.pattern.firstEditableIndex\n  }\n\n  // Bail out or add the character to input\n  if (this.pattern.isEditableIndex(inputIndex)) {\n    if (!this.pattern.isValidAtIndex(char, inputIndex)) {\n      return false\n    }\n    this.value[inputIndex] = this.pattern.transform(char, inputIndex)\n  }\n\n  // If multiple characters were selected, blank the remainder out based on the\n  // pattern.\n  var end = this.selection.end - 1\n  while (end > inputIndex) {\n    if (this.pattern.isEditableIndex(end)) {\n      this.value[end] = this.placeholderChar\n    }\n    end--\n  }\n\n  // Advance the cursor to the next character\n  this.selection.start = this.selection.end = inputIndex + 1\n\n  // Skip over any subsequent static characters\n  while (this.pattern.length > this.selection.start &&\n         !this.pattern.isEditableIndex(this.selection.start)) {\n    this.selection.start++\n    this.selection.end++\n  }\n\n  // History\n  if (this._historyIndex != null) {\n    // Took more input after undoing, so blow any subsequent history away\n    console.log('splice(', this._historyIndex, this._history.length - this._historyIndex, ')')\n    this._history.splice(this._historyIndex, this._history.length - this._historyIndex)\n    this._historyIndex = null\n  }\n  if (this._lastOp !== 'input' ||\n      selectionBefore.start !== selectionBefore.end ||\n      this._lastSelection !== null && selectionBefore.start !== this._lastSelection.start) {\n    this._history.push({value: valueBefore, selection: selectionBefore, lastOp: this._lastOp})\n  }\n  this._lastOp = 'input'\n  this._lastSelection = copy(this.selection)\n\n  return true\n}\n\n/**\n * Attempts to delete from the value based on the current cursor position or\n * selection.\n * @return {boolean} true if the value or selection changed as the result of\n *   backspacing, false otherwise.\n */\nInputMask.prototype.backspace = function backspace() {\n  // If the cursor is at the start there's nothing to do\n  if (this.selection.start === 0 && this.selection.end === 0) {\n    return false\n  }\n\n  var selectionBefore = copy(this.selection)\n  var valueBefore = this.getValue()\n\n  // No range selected - work on the character preceding the cursor\n  if (this.selection.start === this.selection.end) {\n    if (this.pattern.isEditableIndex(this.selection.start - 1)) {\n      this.value[this.selection.start - 1] = this.placeholderChar\n    }\n    this.selection.start--\n    this.selection.end--\n  }\n  // Range selected - delete characters and leave the cursor at the start of the selection\n  else {\n    var end = this.selection.end - 1\n    while (end >= this.selection.start) {\n      if (this.pattern.isEditableIndex(end)) {\n        this.value[end] = this.placeholderChar\n      }\n      end--\n    }\n    this.selection.end = this.selection.start\n  }\n\n  // History\n  if (this._historyIndex != null) {\n    // Took more input after undoing, so blow any subsequent history away\n    this._history.splice(this._historyIndex, this._history.length - this._historyIndex)\n  }\n  if (this._lastOp !== 'backspace' ||\n      selectionBefore.start !== selectionBefore.end ||\n      this._lastSelection !== null && selectionBefore.start !== this._lastSelection.start) {\n    this._history.push({value: valueBefore, selection: selectionBefore, lastOp: this._lastOp})\n  }\n  this._lastOp = 'backspace'\n  this._lastSelection = copy(this.selection)\n\n  return true\n}\n\n/**\n * Attempts to paste a string of input at the current cursor position or over\n * the top of the current selection.\n * Invalid content at any position will cause the paste to be rejected, and it\n * may contain static parts of the mask's pattern.\n * @param {string} input\n * @return {boolean} true if the paste was successful, false otherwise.\n */\nInputMask.prototype.paste = function paste(input) {\n  // This is necessary because we're just calling input() with each character\n  // and rolling back if any were invalid, rather than checking up-front.\n  var initialState = {\n    value: this.value.slice(),\n    selection: copy(this.selection),\n    _lastOp: this._lastOp,\n    _history: this._history.slice(),\n    _historyIndex: this._historyIndex,\n    _lastSelection: copy(this._lastSelection)\n  }\n\n  // If there are static characters at the start of the pattern and the cursor\n  // or selection is within them, the static characters must match for a valid\n  // paste.\n  if (this.selection.start < this.pattern.firstEditableIndex) {\n    for (var i = 0, l = this.pattern.firstEditableIndex - this.selection.start; i < l; i++) {\n      if (input.charAt(i) !== this.pattern.pattern[i]) {\n        return false\n      }\n    }\n\n    // Continue as if the selection and input started from the editable part of\n    // the pattern.\n    input = input.substring(this.pattern.firstEditableIndex - this.selection.start)\n    this.selection.start = this.pattern.firstEditableIndex\n  }\n\n  for (i = 0, l = input.length;\n       i < l && this.selection.start <= this.pattern.lastEditableIndex;\n       i++) {\n    var valid = this.input(input.charAt(i))\n    // Allow static parts of the pattern to appear in pasted input - they will\n    // already have been stepped over by input(), so verify that the value\n    // deemed invalid by input() was the expected static character.\n    if (!valid) {\n      if (this.selection.start > 0) {\n        // XXX This only allows for one static character to be skipped\n        var patternIndex = this.selection.start - 1\n        if (!this.pattern.isEditableIndex(patternIndex) &&\n            input.charAt(i) === this.pattern.pattern[patternIndex]) {\n          continue\n        }\n      }\n      extend(this, initialState)\n      return false\n    }\n  }\n\n  return true\n}\n\n// History\n\nInputMask.prototype.undo = function undo() {\n  // If there is no history, or nothing more on the history stack, we can't undo\n  if (this._history.length === 0 || this._historyIndex === 0) {\n    return false\n  }\n\n  var historyItem\n  if (this._historyIndex == null) {\n    // Not currently undoing, set up the initial history index\n    this._historyIndex = this._history.length - 1\n    historyItem = this._history[this._historyIndex]\n    // Add a new history entry if anything has changed since the last one, so we\n    // can redo back to the initial state we started undoing from.\n    var value = this.getValue()\n    if (historyItem.value !== value ||\n        historyItem.selection.start !== this.selection.start ||\n        historyItem.selection.end !== this.selection.end) {\n      this._history.push({value: value, selection: copy(this.selection), lastOp: this._lastOp, startUndo: true})\n    }\n  }\n  else {\n    historyItem = this._history[--this._historyIndex]\n  }\n\n  this.value = historyItem.value.split('')\n  this.selection = historyItem.selection\n  this._lastOp = historyItem.lastOp\n  return true\n}\n\nInputMask.prototype.redo = function redo() {\n  if (this._history.length === 0 || this._historyIndex == null) {\n    return false\n  }\n  var historyItem = this._history[++this._historyIndex]\n  // If this is the last history item, we're done redoing\n  if (this._historyIndex === this._history.length - 1) {\n    this._historyIndex = null\n    // If the last history item was only added to start undoing, remove it\n    if (historyItem.startUndo) {\n      this._history.pop()\n    }\n  }\n  this.value = historyItem.value.split('')\n  this.selection = historyItem.selection\n  this._lastOp = historyItem.lastOp\n  return true\n}\n\n// Getters & setters\n\nInputMask.prototype.setPattern = function setPattern(pattern, options) {\n  options = extend({\n    selection: {start: 0, end: 0},\n    value: ''\n  }, options)\n  this.pattern = new Pattern(pattern, this.formatCharacters, this.placeholderChar)\n  this.setValue(options.value)\n  this.emptyValue = this.pattern.formatValue([]).join('')\n  this.selection = options.selection\n  this._resetHistory()\n}\n\nInputMask.prototype.setSelection = function setSelection(selection) {\n  this.selection = copy(selection)\n  if (this.selection.start === this.selection.end) {\n    if (this.selection.start < this.pattern.firstEditableIndex) {\n      this.selection.start = this.selection.end = this.pattern.firstEditableIndex\n      return true\n    }\n    if (this.selection.end > this.pattern.lastEditableIndex + 1) {\n      this.selection.start = this.selection.end = this.pattern.lastEditableIndex + 1\n      return true\n    }\n  }\n  return false\n}\n\nInputMask.prototype.setValue = function setValue(value) {\n  if (value == null) {\n    value = ''\n  }\n  this.value = this.pattern.formatValue(value.split(''))\n}\n\nInputMask.prototype.getValue = function getValue() {\n  return this.value.join('')\n}\n\nInputMask.prototype.getRawValue = function getRawValue() {\n  var rawValue = []\n  for (var i = 0; i < this.value.length; i++) {\n    if (this.pattern._editableIndices[i] === true) {\n      rawValue.push(this.value[i])\n    }\n  }\n  return rawValue.join('')\n}\n\nInputMask.prototype._resetHistory = function _resetHistory() {\n  this._history = []\n  this._historyIndex = null\n  this._lastOp = null\n  this._lastSelection = copy(this.selection)\n}\n\nInputMask.Pattern = Pattern\n\nmodule.exports = InputMask\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/inputmask-core/lib/index.js\n ** module id = 7\n ** module chunks = 0\n **/","/**\n * Copyright 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactDOMSelection\n */\n\n'use strict';\n\nvar ExecutionEnvironment = require('fbjs/lib/ExecutionEnvironment');\n\nvar getNodeForCharacterOffset = require('./getNodeForCharacterOffset');\nvar getTextContentAccessor = require('./getTextContentAccessor');\n\n/**\n * While `isCollapsed` is available on the Selection object and `collapsed`\n * is available on the Range object, IE11 sometimes gets them wrong.\n * If the anchor/focus nodes and offsets are the same, the range is collapsed.\n */\nfunction isCollapsed(anchorNode, anchorOffset, focusNode, focusOffset) {\n  return anchorNode === focusNode && anchorOffset === focusOffset;\n}\n\n/**\n * Get the appropriate anchor and focus node/offset pairs for IE.\n *\n * The catch here is that IE's selection API doesn't provide information\n * about whether the selection is forward or backward, so we have to\n * behave as though it's always forward.\n *\n * IE text differs from modern selection in that it behaves as though\n * block elements end with a new line. This means character offsets will\n * differ between the two APIs.\n *\n * @param {DOMElement} node\n * @return {object}\n */\nfunction getIEOffsets(node) {\n  var selection = document.selection;\n  var selectedRange = selection.createRange();\n  var selectedLength = selectedRange.text.length;\n\n  // Duplicate selection so we can move range without breaking user selection.\n  var fromStart = selectedRange.duplicate();\n  fromStart.moveToElementText(node);\n  fromStart.setEndPoint('EndToStart', selectedRange);\n\n  var startOffset = fromStart.text.length;\n  var endOffset = startOffset + selectedLength;\n\n  return {\n    start: startOffset,\n    end: endOffset\n  };\n}\n\n/**\n * @param {DOMElement} node\n * @return {?object}\n */\nfunction getModernOffsets(node) {\n  var selection = window.getSelection && window.getSelection();\n\n  if (!selection || selection.rangeCount === 0) {\n    return null;\n  }\n\n  var anchorNode = selection.anchorNode;\n  var anchorOffset = selection.anchorOffset;\n  var focusNode = selection.focusNode;\n  var focusOffset = selection.focusOffset;\n\n  var currentRange = selection.getRangeAt(0);\n\n  // In Firefox, range.startContainer and range.endContainer can be \"anonymous\n  // divs\", e.g. the up/down buttons on an <input type=\"number\">. Anonymous\n  // divs do not seem to expose properties, triggering a \"Permission denied\n  // error\" if any of its properties are accessed. The only seemingly possible\n  // way to avoid erroring is to access a property that typically works for\n  // non-anonymous divs and catch any error that may otherwise arise. See\n  // https://bugzilla.mozilla.org/show_bug.cgi?id=208427\n  try {\n    /* eslint-disable no-unused-expressions */\n    currentRange.startContainer.nodeType;\n    currentRange.endContainer.nodeType;\n    /* eslint-enable no-unused-expressions */\n  } catch (e) {\n    return null;\n  }\n\n  // If the node and offset values are the same, the selection is collapsed.\n  // `Selection.isCollapsed` is available natively, but IE sometimes gets\n  // this value wrong.\n  var isSelectionCollapsed = isCollapsed(selection.anchorNode, selection.anchorOffset, selection.focusNode, selection.focusOffset);\n\n  var rangeLength = isSelectionCollapsed ? 0 : currentRange.toString().length;\n\n  var tempRange = currentRange.cloneRange();\n  tempRange.selectNodeContents(node);\n  tempRange.setEnd(currentRange.startContainer, currentRange.startOffset);\n\n  var isTempRangeCollapsed = isCollapsed(tempRange.startContainer, tempRange.startOffset, tempRange.endContainer, tempRange.endOffset);\n\n  var start = isTempRangeCollapsed ? 0 : tempRange.toString().length;\n  var end = start + rangeLength;\n\n  // Detect whether the selection is backward.\n  var detectionRange = document.createRange();\n  detectionRange.setStart(anchorNode, anchorOffset);\n  detectionRange.setEnd(focusNode, focusOffset);\n  var isBackward = detectionRange.collapsed;\n\n  return {\n    start: isBackward ? end : start,\n    end: isBackward ? start : end\n  };\n}\n\n/**\n * @param {DOMElement|DOMTextNode} node\n * @param {object} offsets\n */\nfunction setIEOffsets(node, offsets) {\n  var range = document.selection.createRange().duplicate();\n  var start, end;\n\n  if (offsets.end === undefined) {\n    start = offsets.start;\n    end = start;\n  } else if (offsets.start > offsets.end) {\n    start = offsets.end;\n    end = offsets.start;\n  } else {\n    start = offsets.start;\n    end = offsets.end;\n  }\n\n  range.moveToElementText(node);\n  range.moveStart('character', start);\n  range.setEndPoint('EndToStart', range);\n  range.moveEnd('character', end - start);\n  range.select();\n}\n\n/**\n * In modern non-IE browsers, we can support both forward and backward\n * selections.\n *\n * Note: IE10+ supports the Selection object, but it does not support\n * the `extend` method, which means that even in modern IE, it's not possible\n * to programmatically create a backward selection. Thus, for all IE\n * versions, we use the old IE API to create our selections.\n *\n * @param {DOMElement|DOMTextNode} node\n * @param {object} offsets\n */\nfunction setModernOffsets(node, offsets) {\n  if (!window.getSelection) {\n    return;\n  }\n\n  var selection = window.getSelection();\n  var length = node[getTextContentAccessor()].length;\n  var start = Math.min(offsets.start, length);\n  var end = offsets.end === undefined ? start : Math.min(offsets.end, length);\n\n  // IE 11 uses modern selection, but doesn't support the extend method.\n  // Flip backward selections, so we can set with a single range.\n  if (!selection.extend && start > end) {\n    var temp = end;\n    end = start;\n    start = temp;\n  }\n\n  var startMarker = getNodeForCharacterOffset(node, start);\n  var endMarker = getNodeForCharacterOffset(node, end);\n\n  if (startMarker && endMarker) {\n    var range = document.createRange();\n    range.setStart(startMarker.node, startMarker.offset);\n    selection.removeAllRanges();\n\n    if (start > end) {\n      selection.addRange(range);\n      selection.extend(endMarker.node, endMarker.offset);\n    } else {\n      range.setEnd(endMarker.node, endMarker.offset);\n      selection.addRange(range);\n    }\n  }\n}\n\nvar useIEOffsets = ExecutionEnvironment.canUseDOM && 'selection' in document && !('getSelection' in window);\n\nvar ReactDOMSelection = {\n  /**\n   * @param {DOMElement} node\n   */\n  getOffsets: useIEOffsets ? getIEOffsets : getModernOffsets,\n\n  /**\n   * @param {DOMElement|DOMTextNode} node\n   * @param {object} offsets\n   */\n  setOffsets: useIEOffsets ? setIEOffsets : setModernOffsets\n};\n\nmodule.exports = ReactDOMSelection;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/ReactDOMSelection.js\n ** module id = 8\n ** module chunks = 0\n **/","/**\n * Copyright 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactInputSelection\n */\n\n'use strict';\n\nvar ReactDOMSelection = require('./ReactDOMSelection');\n\nvar containsNode = require('fbjs/lib/containsNode');\nvar focusNode = require('fbjs/lib/focusNode');\nvar getActiveElement = require('fbjs/lib/getActiveElement');\n\nfunction isInDocument(node) {\n  return containsNode(document.documentElement, node);\n}\n\n/**\n * @ReactInputSelection: React input selection module. Based on Selection.js,\n * but modified to be suitable for react and has a couple of bug fixes (doesn't\n * assume buttons have range selections allowed).\n * Input selection module for React.\n */\nvar ReactInputSelection = {\n\n  hasSelectionCapabilities: function (elem) {\n    var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();\n    return nodeName && (nodeName === 'input' && elem.type === 'text' || nodeName === 'textarea' || elem.contentEditable === 'true');\n  },\n\n  getSelectionInformation: function () {\n    var focusedElem = getActiveElement();\n    return {\n      focusedElem: focusedElem,\n      selectionRange: ReactInputSelection.hasSelectionCapabilities(focusedElem) ? ReactInputSelection.getSelection(focusedElem) : null\n    };\n  },\n\n  /**\n   * @restoreSelection: If any selection information was potentially lost,\n   * restore it. This is useful when performing operations that could remove dom\n   * nodes and place them back in, resulting in focus being lost.\n   */\n  restoreSelection: function (priorSelectionInformation) {\n    var curFocusedElem = getActiveElement();\n    var priorFocusedElem = priorSelectionInformation.focusedElem;\n    var priorSelectionRange = priorSelectionInformation.selectionRange;\n    if (curFocusedElem !== priorFocusedElem && isInDocument(priorFocusedElem)) {\n      if (ReactInputSelection.hasSelectionCapabilities(priorFocusedElem)) {\n        ReactInputSelection.setSelection(priorFocusedElem, priorSelectionRange);\n      }\n      focusNode(priorFocusedElem);\n    }\n  },\n\n  /**\n   * @getSelection: Gets the selection bounds of a focused textarea, input or\n   * contentEditable node.\n   * -@input: Look up selection bounds of this input\n   * -@return {start: selectionStart, end: selectionEnd}\n   */\n  getSelection: function (input) {\n    var selection;\n\n    if ('selectionStart' in input) {\n      // Modern browser with input or textarea.\n      selection = {\n        start: input.selectionStart,\n        end: input.selectionEnd\n      };\n    } else if (document.selection && input.nodeName && input.nodeName.toLowerCase() === 'input') {\n      // IE8 input.\n      var range = document.selection.createRange();\n      // There can only be one selection per document in IE, so it must\n      // be in our element.\n      if (range.parentElement() === input) {\n        selection = {\n          start: -range.moveStart('character', -input.value.length),\n          end: -range.moveEnd('character', -input.value.length)\n        };\n      }\n    } else {\n      // Content editable or old IE textarea.\n      selection = ReactDOMSelection.getOffsets(input);\n    }\n\n    return selection || { start: 0, end: 0 };\n  },\n\n  /**\n   * @setSelection: Sets the selection bounds of a textarea or input and focuses\n   * the input.\n   * -@input     Set selection bounds of this input or textarea\n   * -@offsets   Object of same form that is returned from get*\n   */\n  setSelection: function (input, offsets) {\n    var start = offsets.start;\n    var end = offsets.end;\n    if (end === undefined) {\n      end = start;\n    }\n\n    if ('selectionStart' in input) {\n      input.selectionStart = start;\n      input.selectionEnd = Math.min(end, input.value.length);\n    } else if (document.selection && input.nodeName && input.nodeName.toLowerCase() === 'input') {\n      var range = input.createTextRange();\n      range.collapse(true);\n      range.moveStart('character', start);\n      range.moveEnd('character', end - start);\n      range.select();\n    } else {\n      ReactDOMSelection.setOffsets(input, offsets);\n    }\n  }\n};\n\nmodule.exports = ReactInputSelection;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/ReactInputSelection.js\n ** module id = 9\n ** module chunks = 0\n **/","/**\n * Copyright 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule getNodeForCharacterOffset\n */\n\n'use strict';\n\n/**\n * Given any node return the first leaf node without children.\n *\n * @param {DOMElement|DOMTextNode} node\n * @return {DOMElement|DOMTextNode}\n */\n\nfunction getLeafNode(node) {\n  while (node && node.firstChild) {\n    node = node.firstChild;\n  }\n  return node;\n}\n\n/**\n * Get the next sibling within a container. This will walk up the\n * DOM if a node's siblings have been exhausted.\n *\n * @param {DOMElement|DOMTextNode} node\n * @return {?DOMElement|DOMTextNode}\n */\nfunction getSiblingNode(node) {\n  while (node) {\n    if (node.nextSibling) {\n      return node.nextSibling;\n    }\n    node = node.parentNode;\n  }\n}\n\n/**\n * Get object describing the nodes which contain characters at offset.\n *\n * @param {DOMElement|DOMTextNode} root\n * @param {number} offset\n * @return {?object}\n */\nfunction getNodeForCharacterOffset(root, offset) {\n  var node = getLeafNode(root);\n  var nodeStart = 0;\n  var nodeEnd = 0;\n\n  while (node) {\n    if (node.nodeType === 3) {\n      nodeEnd = nodeStart + node.textContent.length;\n\n      if (nodeStart <= offset && nodeEnd >= offset) {\n        return {\n          node: node,\n          offset: offset - nodeStart\n        };\n      }\n\n      nodeStart = nodeEnd;\n    }\n\n    node = getLeafNode(getSiblingNode(node));\n  }\n}\n\nmodule.exports = getNodeForCharacterOffset;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/getNodeForCharacterOffset.js\n ** module id = 10\n ** module chunks = 0\n **/","/**\n * Copyright 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule getTextContentAccessor\n */\n\n'use strict';\n\nvar ExecutionEnvironment = require('fbjs/lib/ExecutionEnvironment');\n\nvar contentKey = null;\n\n/**\n * Gets the key used to access text content on a DOM node.\n *\n * @return {?string} Key used to access text content.\n * @internal\n */\nfunction getTextContentAccessor() {\n  if (!contentKey && ExecutionEnvironment.canUseDOM) {\n    // Prefer textContent to innerText because many browsers support both but\n    // SVG <text> elements don't support innerText even when <div> does.\n    contentKey = 'textContent' in document.documentElement ? 'textContent' : 'innerText';\n  }\n  return contentKey;\n}\n\nmodule.exports = getTextContentAccessor;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/getTextContentAccessor.js\n ** module id = 11\n ** module chunks = 0\n **/","module.exports = __WEBPACK_EXTERNAL_MODULE_12__;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** external {\"root\":\"React\",\"commonjs2\":\"react\",\"commonjs\":\"react\",\"amd\":\"react\"}\n ** module id = 12\n ** module chunks = 0\n **/"],"sourceRoot":""}